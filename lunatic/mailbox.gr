import WasmI32 from "runtime/unsafe/wasmi32"
import WasmI64 from "runtime/unsafe/wasmi64"
import Memory from "runtime/unsafe/memory"
import DataStructures from "runtime/dataStructures"
import Array from "array"
import Bytes from "bytes"
import Int64 from "int64"
import Marshall from "marshall"
import Result from "result"

import Process from "./process"

import foreign wasm create_data: (
  WasmI64,
  WasmI64,
) -> Void as createData from "lunatic::message"
import foreign wasm write_data: (
  WasmI32,
  WasmI32,
) -> WasmI32 as writeData from "lunatic::message"
import foreign wasm read_data: (
  WasmI32,
  WasmI32,
) -> WasmI32 as readData from "lunatic::message"
import foreign wasm seek_data: WasmI64 -> Void as seekData from "lunatic::message"
import foreign wasm get_tag: () -> WasmI64 as getTag from "lunatic::message"
import foreign wasm data_size: () -> WasmI64 as dataSize from "lunatic::message"
import foreign wasm send: WasmI64 -> Void from "lunatic::message"
import foreign wasm receive: (
  WasmI32,
  WasmI32,
  WasmI32,
) -> WasmI32 from "lunatic::message"

export exception ReceiveTimeout

type Mailbox<a> = Int64

@unsafe
let mut currentTag = 128N

@unsafe
export let create = () => {
  let tag = currentTag
  currentTag = WasmI64.add(currentTag, 1N)
  WasmI32.toGrain(DataStructures.newInt64(tag)): Mailbox<a>
}

@unsafe
let createData = (tag: Int64, capacity: Int64) => {
  createData(
    WasmI64.load(WasmI32.fromGrain(tag), 8n),
    WasmI64.load(WasmI32.fromGrain(capacity), 8n)
  )
}

@unsafe
let writeData = (bytes: Bytes) => {
  let bytesPtr = WasmI32.fromGrain(bytes)
  let bytesWritten = writeData(
    WasmI32.add(bytesPtr, 8n),
    WasmI32.load(bytesPtr, 4n)
  )
  WasmI32.toGrain(DataStructures.newInt32(bytesWritten)): Int32
}

@unsafe
let readData = (bytes: Bytes) => {
  let bytesPtr = WasmI32.fromGrain(bytes)
  let bytesRead = readData(
    WasmI32.add(bytesPtr, 8n),
    WasmI32.load(bytesPtr, 4n)
  )
  WasmI32.toGrain(DataStructures.newInt32(bytesRead)): Int32
}

@unsafe
let seekData = (position: Int64) => {
  seekData(WasmI64.load(WasmI32.fromGrain(position), 8n))
}

@unsafe
let getTag = () => {
  WasmI32.toGrain(DataStructures.newInt64(getTag())): Int64
}

@unsafe
let dataSize = () => {
  WasmI32.toGrain(DataStructures.newInt64(dataSize())): Int64
}

@unsafe
let send = (pid: Process.Process) => {
  send(WasmI64.load(WasmI32.fromGrain(pid), 8n))
}

@unsafe
let receive = (tags: Option<List<Int64>>, timeout: Int32) => {
  let tags = match (tags) {
    Some(tags) => Array.fromList(tags),
    None => [>],
  }

  let count = DataStructures.untagSimpleNumber(Array.length(tags))

  let tagsBuf = Memory.malloc(WasmI32.mul(count, 8n))

  for (let mut i = 0n; WasmI32.ltU(i, count); i = WasmI32.add(i, 1n)) {
    WasmI64.store(
      tagsBuf,
      WasmI64.load(
        WasmI32.fromGrain(tags[DataStructures.tagSimpleNumber(i)]),
        8n
      ),
      WasmI32.mul(i, 8n)
    )
  }

  let result = receive(
    tagsBuf,
    count,
    WasmI32.load(WasmI32.fromGrain(timeout), 8n)
  )

  match (result) {
    0n => {
      Ok(void)
    },
    9027n => Err(ReceiveTimeout),
    1n => fail "can't recieve link failed message",
    _ => fail "unknown receive error",
  }
}

export let send: (Process.Process, a, Mailbox<a>) -> Void =
  (
    process,
    data,
    mailbox,
  ) => {
  let payload = Marshall.marshall(data)
  createData(mailbox, Int64.fromNumber(Bytes.length(payload)))
  writeData(payload)
  send(process)
}

export let receive: (Int32, Mailbox<a>) -> Result<a, Exception> =
  (
    timeout,
    mailbox,
  ) => {
  Result.map((_) => {
    let size = dataSize()
    let buf = Bytes.make(Int64.toNumber(size))
    readData(buf)
    Marshall.unmarshall(buf)
  }, receive(Some([mailbox]), timeout))
}
